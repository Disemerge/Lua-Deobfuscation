## About obfuscation (Lua/Roblox)

- [About obfuscation (Lua/Roblox)](#about-obfuscation)
  * [VM (Virtual Machine)](#vm-virtual-machine)
  * [Loadstring](#loadstring)
- [Defeat obfuscation](#defeat-obfuscation)
  * [VM obfuscation](#vm-obfuscation)
    + [Examples from ironbrew](#examples-from-ironbrew)

### VM Virtual Machine
Lua VM obfuscation is a technique used to protect Lua code from reverse engineering or tampering by making it difficult to understand or modify by someone who doesn't have access to the original source code. The Lua Virtual Machine (VM) is responsible for interpreting and executing Lua code, and obfuscation techniques can be applied to the bytecode generated by the VM to make it harder to read and modify.

Some common techniques used for Lua VM obfuscation include:

1.  **Bytecode scrambling:** This technique involves rearranging the bytecode instructions in a random order, making it harder to understand the flow of the code.
    
2.  **Opcode substitution:** In this technique, the original opcodes are replaced with different ones that perform the same function, but are harder to recognize.
    
3.  **Constant encryption:** This involves encrypting the string and number constants used in the code, making it difficult to extract sensitive information.
    
4.  **Control flow obfuscation:** This technique involves altering the control flow of the code by inserting dummy code or jump instructions, making it harder to follow the actual logic of the code.

These techniques can be applied individually or in combination to make it harder to reverse engineer or modify the Lua code. However, it's important to note that obfuscation is not foolproof and can be circumvented by determined attackers with sufficient time and resources.

### Loadstring
Loadstring obfuscation is a common technique to hide code within a loadstring. using loadstring is a security risk because it can be easily dumped by skids.
```lua
loadstring = print
```

Some obfuscators like PSU use this to their advantage for example
```lua
loadstring(string.sub(decompressedbytecode, LuaHeaders))(Table, ...)
```
The `decompressedbyte` is the second layer of obfuscation which ran by the ``Loadstring`` function which passes the `Table` object into it so if you just print and run the generated code it simply will not work.

## Defeat obfuscation

### VM obfuscation
There are multiple factors towards defeating `VM obfuscation` like finding the decompress function which turns the bytecode into `lua opcodes` which gets run by the vm aka an interpreter.

#### Examples from ironbrew 
We will use Ironbrew for this example because it isn't crowdy or hard to read which makes it easy to read and understand what is happening.

The `decompress` function takes a single argument which is the compressed binary string. The string is decompressed using a variation of the Lempel-Ziv-Welch (LZW) compression algorithm.
```lua
-- Example decompress function
local function decompress(b)
	local c,d,e = "","",{}
	local f = 256;
	local g = {}
	
	for h=0,f-1 do
		g[h]=Char(h)
	end;
	
	local i = 1;
	
	local function k()
		local l = ToNumber(Sub(b, i, i), 36)
		i = i + 1;
		local m = ToNumber(Sub(b, i, i + l - 1), 36)
		i = i + l;
		return m
	end;
	
	c = Char(k())
	e[1] = c;
	
	while i < #b do
		local n = k()
		if g[n]then
			d = g[n]
		else
			d = c..Sub(c, 1,1)
		end;
		g[f] = c..Sub(d, 1,1)
		e[#e+1], c, f = d, d , f + 1
	end;
	return table.concat(e)
end;

local ByteString=decompress(_StringExpr_);
```

Constants are `constant values `defined in the stack which allows the intepreter to 
```lua
-- Constants (The most skiddy way to deobfuscate)
for Idx=1, ConstCount do
	local Type = gBits8();
	local Cons;

	if(Type == _NumberExpr_) then

	elseif(Type == _NumberExpr_) then

	elseif(Type == _NumberExpr_) then

	end;
	Consts[Idx] = Cons;
end;

-- print(table.unpack(Consts)) DEOBFUSCATED AAKAKKAKAKAKk
```

To defeat Ironbrew we need to leak the instructions like every other obfuscator.
The script below iterates every instruction like `JUMP`, `ADD` etc.
```lua
table.foreach(InstructionTable, function(index, a) print(unpack(a)) end)
```

To utilize the script we need to put it in the `WRAP` function of ironbrew, which looks like the function below.
```lua
local function i(l, e, t)
	local n = l[1]
	local e = l[2]
	local l = l[3]
	table.foreach(n, function(index, a) print(unpack(a)) end)
	return function(...)
```
