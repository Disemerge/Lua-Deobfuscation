## About obfuscation (Lua/Roblox)

- [About obfuscation (Lua/Roblox)](#about-obfuscation)
  * [VM (Virtual Machine)](#vm-virtual-machine)
  * [Loadstring](#loadstring)
- [Defeat obfuscation](#defeat-obfuscation)
  * [VM obfuscation](#vm-obfuscation)
    + [Examples from ironbrew](#examples-from-ironbrew)

### VM Virtual Machine
Lua VM obfuscation is a technique used to protect Lua code from reverse engineering or tampering by making it difficult to understand or modify by someone who doesn't have access to the original source code. The Lua Virtual Machine (VM) is responsible for interpreting and executing Lua code, and obfuscation techniques can be applied to the bytecode generated by the VM to make it harder to read and modify.

Some common techniques used for Lua VM obfuscation include:

1.  **Bytecode scrambling:** This technique involves rearranging the bytecode instructions in a random order, making it harder to understand the flow of the code.
    
2.  **Opcode substitution:** In this technique, the original opcodes are replaced with different ones that perform the same function, but are harder to recognize.
    
3.  **Constant encryption:** This involves encrypting the string and number constants used in the code, making it difficult to extract sensitive information.
    
4.  **Control flow obfuscation:** This technique involves altering the control flow of the code by inserting dummy code or jump instructions, making it harder to follow the actual logic of the code.

These techniques can be applied individually or in combination to make it harder to reverse engineer or modify the Lua code. However, it's important to note that obfuscation is not foolproof and can be circumvented by determined attackers with sufficient time and resources.

### Loadstring
In Lua, the `loadstring` function can be used to load a string containing Lua code and execute it as a function. This function can be obfuscated, or obscured, by manipulating the string containing the Lua code in such a way that it is difficult for a human to read and understand, but still executable by the `loadstring` function.

The script below can defeat any loadstring obfuscation, Yes its really that simple I know.
```lua
loadstring = print
```

Some obfuscators like PSU use this to their advantage. (Script below taken from PSU obfuscated code)
The `decompressedbyte` is the second layer of obfuscation which ran by the ``Loadstring`` function which passes the `Table` object.
```lua
loadstring(string.sub(decompressedbytecode, LuaHeaders))(Table, ...)
```


## Defeat obfuscation

### VM obfuscation
There are multiple factors towards defeating `VM obfuscation` like finding the decompress function which turns the bytecode into `lua opcodes` which gets run by the vm aka an interpreter.

#### Examples from ironbrew 
We will use Ironbrew for this example because it isn't crowdy or hard to read which makes it easy to read and understand what is happening.

The `decompress` function takes a single argument which is the compressed binary string. The string is decompressed using a variation of the Lempel-Ziv-Welch (LZW) compression algorithm.
```lua
-- Example decompress function
local function decompress(b)
	local c,d,e = "","",{}
	local f = 256;
	local g = {}
	
	for h=0,f-1 do
		g[h]=Char(h)
	end;
	
	local i = 1;
	
	local function k()
		local l = ToNumber(Sub(b, i, i), 36)
		i = i + 1;
		local m = ToNumber(Sub(b, i, i + l - 1), 36)
		i = i + l;
		return m
	end;
	
	c = Char(k())
	e[1] = c;
	
	while i < #b do
		local n = k()
		if g[n]then
			d = g[n]
		else
			d = c..Sub(c, 1,1)
		end;
		g[f] = c..Sub(d, 1,1)
		e[#e+1], c, f = d, d , f + 1
	end;
	return table.concat(e)
end;

local ByteString=decompress(_StringExpr_);
```

In a Lua virtual machine (VM), constants are represented as values that are stored in the VM's constant table. When a Lua script is executed, the VM loads all of the constants defined in the script into the constant table.

The `constant` table is a separate data structure from the VM's stack, which is used to store `temporary values `during script execution. Constants are loaded into the `constant table `at the beginning of script execution and are then accessed from the constant table as needed.
```lua
-- Constants (The most skiddy way to deobfuscate)
for Idx=1, ConstCount do
	local Type = gBits8();
	local Cons;

	if(Type == _NumberExpr_) then

	elseif(Type == _NumberExpr_) then

	elseif(Type == _NumberExpr_) then

	end;
	Consts[Idx] = Cons; -- Consts = constant table
end;
```

To defeat Ironbrew we need to leak the instructions like every other obfuscator.
The script below iterates every instruction like `JUMP`, `ADD` etc.
```lua
table.foreach(InstructionTable, function(index, a) print(unpack(a)) end)
```

To utilize the script we need to put it in the `WRAP` function of ironbrew, which looks like the function below.
```lua
local function i(l, e, t)
	local n = l[1]
	local e = l[2]
	local l = l[3]
	table.foreach(n, function(index, a) print(unpack(a)) end)
	return function(...)
```
